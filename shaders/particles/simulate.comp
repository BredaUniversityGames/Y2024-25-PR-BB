#version 460
#extension GL_EXT_nonuniform_qualifier: enable

#include "../scene.glsl"
#include "../bindless.glsl"
#include "particle_binds.glsl"

layout (set = 2, binding = 0) buffer CulledInstancesSSB
{
    CulledInstances culledInstances;
};

layout (set = 3, binding = 0) uniform CameraUBO
{
    Camera camera;
};

layout (push_constant) uniform PushConstants
{
    float deltaTime;
    float screenWidth;
    float screenHeight;
    uint positionIndex;
};

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

bool IsVisible(vec3 position, float size);
bool CollidesWithDepth(vec3 position, float size);

void main()
{
    uint index = gl_GlobalInvocationID.x;
    uint aliveCount = particleCounters.aliveCount;
    if (index >= aliveCount)
    {
        return;
    }

    uint particleIndex = aliveBufferCURRENT[index];
    Particle particle = particles[particleIndex];

    particle.life -= deltaTime;

    if (particle.life > 0)
    {
        // simulate particles
        particle.velocity.y -= particle.mass * deltaTime;
        particle.position += particle.velocity * deltaTime;

        // TODO: simulate size
        float biggestSize = max(particle.size.x, particle.size.y);

        // kill particle on depth collision
        if (CollidesWithDepth(particle.position, biggestSize))
        {
            // add to dead buffer
            uint deadIndex = atomicAdd(particleCounters.deadCount, 1);
            deadBuffer[deadIndex] = particleIndex;
            return;
        }

        // simulate angle
        particle.rotationVelocity.x += particle.rotationVelocity.y * deltaTime;

        // write simulated particle back into particle buffer
        particles[particleIndex] = particle;

        // add to new alive list
        uint newAliveIndex = atomicAdd(particleCounters.aliveCountAfterSimulation, 1);
        aliveBufferNEW[newAliveIndex] = particleIndex;

        // only visible particles go into the rendering buffer after frustum culling
        if (IsVisible(particle.position, biggestSize))
        {
            uint culledIndex = atomicAdd(culledInstances.count, 1);
            ParticleInstance instance;
            instance.position = particle.position;
            instance.materialIndex = particle.materialIndex;
            instance.size = particle.size.xy;
            instance.angle = particle.rotationVelocity.x;
            instance.flags = particle.flags;
            culledInstances.instances[culledIndex] = instance;
        }
    }
    else // if dead
    {
        // add to dead buffer
        uint deadIndex = atomicAdd(particleCounters.deadCount, 1);
        deadBuffer[deadIndex] = particleIndex;
    }
}

bool IsVisible(vec3 position, float size)
{
    vec3 center = (camera.view * vec4(position, 1.f)).xyz;
    float radius = size;
    bool visible = true;

    // Test against frustum.
    if (camera.projectionType == 0)
    {
        visible = visible && center.z * camera.frustum[1] - abs(center.x) * camera.frustum[0] > -radius;
        visible = visible && center.z * camera.frustum[3] - abs(center.y) * camera.frustum[2] > -radius;
    }
    else if (camera.projectionType == 1)
    {
        visible = visible && center.x + radius > camera.frustum[0];// Left plane
        visible = visible && center.x - radius < camera.frustum[1];// Right plane
        visible = visible && center.y + radius > camera.frustum[2];// Bottom plane
        visible = visible && center.y - radius < camera.frustum[3];// Top plane
    }

    if (camera.distanceCullingEnabled != 0)
    {
        // Test against near and far plane.
        visible = visible && -center.z + radius > camera.zNear && -center.z - radius < camera.zFar;
    }

    visible = visible && camera.cullingEnabled != 0;

    return visible;
}

bool CollidesWithDepth(vec3 position, float size)
{
    bool collides = false;

    vec4 position2D = (camera.VP) * vec4(position, 1.0);
    position2D.xyz /= position2D.w;

    if (position2D.x > -1 && position2D.x < 1 && position2D.y > -1 && position2D.y < 1)
    {
        vec2 uv;
        uv.x = ((position2D.x + 1.0) * 0.5 * screenWidth) / screenWidth;
        uv.y = ((1.0 - position2D.y) * 0.5 * screenHeight) / screenHeight;
        vec4 testPosition = texture(bindless_color_textures[nonuniformEXT(positionIndex)], uv);

        if (length(position - testPosition.xyz) <= (size * 2.0))// doubling since otherwise it's too small to check with lol
        {
            collides = true;
        }
    }

    return collides;
}