#version 460

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

#define MAX_LIGHTS_PER_CLUSTER 128

#include "scene.glsl"
#include "clusters.glsl"

layout (set = 0, binding = 0) readonly buffer Clusters { AABB clusters[]; }; //Input

layout (set = 1, binding = 0) readonly buffer Lights { PointLightArray lights; }; //Input

layout (set = 2, binding = 0) buffer AtomicCounter { uint globalIndex; }; //Output
layout (set = 2, binding = 1) buffer LightCells { LightCell lightCells[]; }; //Output
layout (set = 2, binding = 2) buffer LightIndices { uint lightIndices[]; }; //Output
layout (set = 3, binding = 0) uniform CameraUBO { Camera camera; }; //Input

float SquaredDistancePointAABB(vec3 point, uint tile)
{
    AABB currentCell = clusters[tile];
    float squaredDistance = 0.0;

    for (uint i = 0; i < 3; ++i) {
        float v = point[i];
        if (v < currentCell.min[i])
        {
            float diff = currentCell.min[i] - v;
            squaredDistance += (diff * diff);
        }
        if (v > currentCell.max[i])
        {
            float diff = v - currentCell.max[i];
            squaredDistance += (diff * diff);
        }
    }
    return squaredDistance;
}

bool TestSphereAABB(uint lightIndex, uint tile)
{
    float lightRadius = lights.lights[lightIndex].range;
    vec4 lightPosition = lights.lights[lightIndex].position;
    vec4 positionView = camera.view * lightPosition;
    float squaredDistance = SquaredDistancePointAABB(positionView.xyz, tile);

    return squaredDistance < (lightRadius * lightRadius);
}

void main()
{
    uint tileIndex =
    gl_WorkGroupID.x +
    gl_WorkGroupID.y * gl_NumWorkGroups.x +
    gl_WorkGroupID.z * gl_NumWorkGroups.x * gl_NumWorkGroups.y;

    uint visibleLightIndices[MAX_LIGHTS_PER_CLUSTER];

    uint lightIterator = 0;
    for (uint i = 0; i < lights.count && lightIterator < MAX_LIGHTS_PER_CLUSTER; ++i)
    {
        if (TestSphereAABB(i, tileIndex)) {
            visibleLightIndices[lightIterator++] = i;
        }
    }

    uint offset = atomicAdd(globalIndex, lightIterator);

    for (uint i = 0; i < lightIterator; ++i)
    {
        lightIndices[offset + i] = visibleLightIndices[i];
    }

    lightCells[tileIndex].offset = offset;
    lightCells[tileIndex].count = lightIterator;
}
