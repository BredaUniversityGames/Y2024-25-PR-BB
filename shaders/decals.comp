#version 460
#extension GL_EXT_nonuniform_qualifier: enable

#include "bindless.glsl"
#include "scene.glsl"
#include "octahedron.glsl"

layout (push_constant) uniform PushConstants
{
    uint albedoMIndex;
    uint normalRIndex;
    uint depthIndex;
    uvec2 screenSize;
    float decalNormalThreshold;
    uint decalCount;
} pushConstants;

layout (set = 1, binding = 0) uniform CameraUBO
{
    Camera camera;
};

layout (set = 2, binding = 0) uniform DecalUBO
{
    Decal decals[MAX_DECALS];
};

layout (set = 3, binding = 0, rgba32f) writeonly uniform image2D outputTexture;

// TODO: check if I can also dispatch separate work groups for decals in local_size_z
layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

void main()
{
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);

    vec2 texelSize = vec2(1.0f) / pushConstants.screenSize;
    vec2 uv = vec2(pixelCoords) / pushConstants.screenSize;
    uv += texelSize * 0.5f;

    vec4 albedo = texelFetch(bindless_color_textures[nonuniformEXT(pushConstants.albedoMIndex)], pixelCoords, 0);
    vec4 normalSample = texelFetch(bindless_color_textures[nonuniformEXT(pushConstants.normalRIndex)], pixelCoords, 0);
    float depthSample = texelFetch(bindless_depth_textures[nonuniformEXT(pushConstants.depthIndex)], pixelCoords, 0).r;

    vec3 normal = OctDecode(normalSample.rg);
    vec3 position = ReconstructWorldPosition(depthSample, uv, camera.inverseVP);

    // Decal calculations
    for (uint decalIndex = 0; decalIndex < pushConstants.decalCount; decalIndex++)
    {
        Decal currentDecal = decals[decalIndex];

        // transform pixel pos to decal box space
        vec4 positionObjectSpace = currentDecal.invModel * vec4(position, 1.0f);

        // check if pixel is within decal box
        if (abs(positionObjectSpace.x) - 0.5f <= 0.0f &&
        abs(positionObjectSpace.y) - 0.5f <= 0.0f &&
        abs(positionObjectSpace.z) - 0.5f <= 0.0f)
        {
            // make sure there's no side stretching
            if (dot(normalize(normal), currentDecal.orientation) - pushConstants.decalNormalThreshold > 0.0f)
            {
                vec2 decalTexCoord = positionObjectSpace.xy + 0.5f;
                vec4 decalAlbedo = texture(bindless_color_textures[nonuniformEXT(currentDecal.albedoIndex)], decalTexCoord);
                float decalBlend = decalAlbedo.w;
                albedo = mix(albedo, vec4(decalAlbedo.xyz, albedo.w), decalBlend);
            }
        }
    }

    imageStore(outputTexture, pixelCoords, albedo);

    // voodoo magic for multiple dispatches for decals:
    // imageAtomicExchange(outputTexture, pixelCoords, mix(texelFetch(bindless_color_textures[nonuniformEXT(pushConstants.albedoRMIndex)], pixelCoords).rgb, decalAlbedo.xyz, decalBlend));
}
